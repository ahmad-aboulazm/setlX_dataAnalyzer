identifyAllClasses := procedure(code, rw allClassesIdentities){

match(code){
	case ^block(x):			 	
		for(y in x){
			identifyAllClasses(y, allClassesIdentities);
		}
		return;
	
	case ^classDefiner(x, y): 	
		allClassesIdentities := allClassesIdentities + {[x, [{},{},{},{}]]}; 
									// [Name, [{parameters},{class variables},
									//	{class proc.s},{class objects}]]
		className := x;
		extractClassProperties(y, className, allClassesIdentities);
	
	default:				 	
		return; //Do Nothing - All what is targeted is the class definition !
}
};


extractClassProperties := procedure(code, name, rw allClassesIdentities){
//print("extractClassProperties: $canonical(code)$");
match(code){
	case ^setlClass([], c, z):		
		match(c){
			case ^block(v)	:	for(w in v){
									addDefinedVariables(w, allClassesIdentities[name][2], false, "", [], false, true);
								}
			default			: 	//print("IMPOSSIBLE IN extractClassProperties");
		}
		identifyAllProcedures(c, allClassesIdentities[name][3]); //Non-static procedures
		identifyAllProcedures(z, allClassesIdentities[name][3]); //static procedures
		addDefinedVariables(z, allClassesIdentities[name][2], false, "", [], false, true);
											
	case ^setlClass([a|b], c, z):	
		for(x in [a|b]){
			match(x){
				case ^parameter(w) 	:	allClassesIdentities[name][1] += {str(w)};
				default				:	//print("IMPOSSIBLE TO REACH!");
			}
		}
		match(c){
			case ^block(v)	:	for(w in v){
									addDefinedVariables(w, allClassesIdentities[name][2], false, "", [], false, true);
								}
			default			: 	//print("IMPOSSIBLE IN extractClassProperties");
		}
		identifyAllProcedures(c, allClassesIdentities[name][3]); //Non-static procedures
		identifyAllProcedures(z, allClassesIdentities[name][3]); //static procedures
		addDefinedVariables(z, allClassesIdentities[name][2], false, "", [], false, true);
	
	default:
		return; //Never ever reached
}
};



getMatchedVariables := procedure(code, rw list){
	code := str(canonical(code));
	parts := split(code, "zzzzzzz");
	parts := split(parts[1], "variable");
	counter := 1;
	if(first(parts) != last(parts)){
		for(x in parts){
			if(counter != 1){
				parts2 := split(x, "\"");
				if(parts2[2] != ""){
					entity := parts2[2];
				}
				list := list + {entity};
			}
			counter+=1;
		}
	}
};


identifyAllProcedures := procedure(code, rw allProceduresIdentities){
//print("identifyAllProcedures : " + canonical(code));
match(code){
	case ^block(x)                  				 		: 	for(y in x){identifyAllProcedures(y, allProceduresIdentities);} 
																return;
	
	case ^assignment(^variable(x), ^procedure(y, z)) 		: 	if(!(x in domain(allProceduresIdentities))){
																   allProceduresIdentities := allProceduresIdentities + {[x, []]};
																}
																else{
																   allProceduresIdentities[x] := [];
																}
																getProcedureIdentity(x, ^procedure(y, z), allProceduresIdentities);
	
	case ^assignment(^variable(x), ^cachedProcedure(y, z))	:	if(!(x in domain(allProceduresIdentities))){
																   allProceduresIdentities := allProceduresIdentities + {[x, []]};
																}
																else{
																   allProceduresIdentities[x] := [];
																}
																getProcedureIdentity(x, ^procedure(y, z), allProceduresIdentities);
																
	case ^assignment(^variable(x), ^lambdaDefinition(y, z))	:	if(!(x in domain(allProceduresIdentities))){
																   allProceduresIdentities := allProceduresIdentities + {[x, []]};
																}
																else{
																   allProceduresIdentities[x] := [];
																}
																getProcedureIdentity(x, ^procedure(y, ^block([z])), allProceduresIdentities);
																return;														
	
	default                        					  		: return; //Do Nothing - All what is targeted is the procedure definition !

}

};


getProcedureIdentity := procedure(name, code, rw allProceduresIdentities){
//print("getProcedureIdentity : " + canonical(code));
	match(code){
	
		case ^procedure(a, b)				:	for(x in a) {getProcedureIdentity(name, x, allProceduresIdentities);}
												return;
		
		case ^parameter(^variable(x))		:	allProceduresIdentities[name] := allProceduresIdentities[name] + ["0"];
												return;
		
		case ^rwParameter(^variable(x))		:	allProceduresIdentities[name] := allProceduresIdentities[name] + ["1"];
												return;
		
		default								:	//print("Impossible if not [] in getProcedureIdentity ! " + canonical(code));
	
	
	}

};


checkProcedure := procedure(name, x, rw allProceduresIdentities, rw allClassesIdentities, classVariables, isClass, className){
//print("checkProcedure : " + canonical(x));
	match(x){

	case ^procedure(y, z):	
		allProcedureDefinedVariables := {};
		allProcedureRWParameters := {};
		//allProceduresIdentities := allProceduresIdentities + {[name, []]};
		getProcedureParameters(^procedure(y, z), allProcedureDefinedVariables, allProcedureRWParameters);
		procedureParameters := allProcedureDefinedVariables;
		allProcedureUsedVariables := {};
		allProcedureDefinedVariables += classVariables;
		checkCode(z, allProcedureDefinedVariables, allProcedureUsedVariables, true, name, procedureParameters,
				{}, allProceduresIdentities, false, {}, {}, {}, isClass, className, allClassesIdentities);
		//print("allProcedureUsedVariables: $allProcedureUsedVariables$");
		unUsedProcVars := (allProcedureDefinedVariables-allProcedureUsedVariables)-allProcedureRWParameters;
		unUsedProcVars -= classVariables;
		if(#unUsedProcVars != 0){
			if(#unUsedProcVars == 1){
				print("Variable " + unUsedProcVars + " is defined but never used in the procedure called " + name + "!!");
			}
			else{
				print("Variables " + unUsedProcVars + " are defined but never used in the procedure called " + name + "!!");									
			}
		}
								

	default:
		//print("This is impossible to reach !");
	}

};


getProcedureParameters := procedure(y, rw allProcedureDefinedVariables, rw allProcedureRWParameters){
//print("getProcedureParameters :" + canonical(y));
	match(y){
	
		case ^procedure(a, b)				:	for(x in a) {getProcedureParameters(x, allProcedureDefinedVariables, allProcedureRWParameters);}	
												return;
		
		case [a|b]							:	for(x in [a|b]) {getProcedureParameters(x, allProcedureDefinedVariables, allProcedureRWParameters);}	
												return;
		
		case ^parameter(^variable(x))		:	allProcedureDefinedVariables := allProcedureDefinedVariables + {x};
												return;
		
		case ^rwParameter(^variable(x))		:	allProcedureDefinedVariables := allProcedureDefinedVariables + {x};
												allProcedureRWParameters := allProcedureRWParameters + {x};
												return;
		
		default								:	//print("Impossible if not [] in getProcedureParameters ! " + canonical(y));
	}

};

analyzeAllLoadedFiles := procedure(code, rw definedVars, rw allUsedVars, rw allProceduresIdentities, rw allClassesIdentities){
match(code){
	case ^block(x):
		for(y in x){
			analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		} 
		return;
	
	case ^ifThen(x):	
		for(y in x){
			analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		}
	
	case ^ifThenElseIfBranch(x, y):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^ifThenBranch(cond, then):
		analyzeAllLoadedFiles(then, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^ifThenElseBranch(x):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^while(x, y):
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^for(x, y, z):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(z, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^tryCatch(x, y):	
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^tryCatchLngBranch(x, y):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^tryCatchUsrBranch(x, y):	
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^tryCatchBranch(x, y):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	case ^check(x, y):
		analyzeAllLoadedFiles(x, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
		analyzeAllLoadedFiles(y, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	
	
	case ^call("load", x):
		for(y in x){
			print("NOW CHECKING LOADED FILE $y$");
			l := readFile(y); 
			l := +/ [ g + "\n" : g in l ];
			l := parseStatements(l);	
			identifyAllProcedures(l, allProceduresIdentities);
			identifyAllClasses(l, allClassesIdentities);
			checkCode(l, definedVars, allUsedVars, false, "", {}, {}, allProceduresIdentities, false, {},
					{}, {}, false, "", allClassesIdentities);
			print("DONE CHECKING LOADED FILE $y$");
		}
		return;
										
	default:	return;

}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
getUsedVariables := procedure(l, rw usedVariables, allUsedVars, rw tempDefinedVars, rw definedVars, isProcedure, procName,
			procParameters, rw procEmbeddedProcedures, iteratorCase, rw allProceduresIdentities, forLoopCase, rw forLoopTmpDefVars,
			exceptionTmp, matchTmp, rw allClassesIdentities, isClass, className)  {
//print("getUsedVariables " + canonical(l));
	match(l){
	
	case ^block(x):
		//print("Code should never reach here as that would definetly cause an internal error due to getting used 
		//variables in multiple statements at the same time " + canonical(l));
		return;
										
	case ^variable(x):
		usedVariables := usedVariables + {x};
		return;
	
	case ^assignment(x, [a|b]):
		for(y in [a|b]){
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase, 
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		}
		return;
	
	case ^assignment(x, ^call(y, z)):
		if(y in domain(allClassesIdentities)){
			allClassesIdentities[y][4] += {str(x)};
			if(#z != #allClassesIdentities[y][1]){
				print("Object $x$ is called to be created of class $y$ with $#z$ parameters instead of $#allClassesIdentities[y][1]$");
			}
			for(i in z){
				allClassesIdentities[y][4] += {str(i)};
			}
		}
		getUsedVariables(^call(y, z), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
	
	case ^assignment(^variable(_), y): 
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^assignment(^assignListConstructor(_), y):
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^assignment(^memberAccess(x, y), z): 
		if(!isClass){
			newClassName := "extra-" + str(x);
			if(!(newClassName in domain(allClassesIdentities))){
				oldClassProperties := {oc : oc in allClassesIdentities | str(x) in oc[2][4]};
				if(#oldClassProperties != 0){
					oldClassProperties := first(oldClassProperties);
					oldClassProperties := oldClassProperties[2];
				}
				else{
					a := {f : g in allClassesIdentities, f in g[2][1]};
					b := {f : g in allClassesIdentities, f in g[2][2]};
					c := {f : g in allClassesIdentities, f in g[2][3]};
					d := {f : g in allClassesIdentities, f in g[2][4]};
					oldClassProperties := [a, b, c, d];
				}
				oldClassProperties[4] := {str(x)};
				oldClassProperties[2] += {str(y)};
				allClassesIdentities := allClassesIdentities + {[newClassName, oldClassProperties]};
			}
			else{
				allClassesIdentities[newClassName][2] += {str(y)};
			}
		}
		getUsedVariables(^memberAccess(x, y), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase, 
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^assignment(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	//Mathematics
	case ^difference(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^sum([x], y):
		for(z in [x]){
			getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^sum(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^sumAssignment(x, [y]):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^sumAssignment(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^differenceAssignment(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		if(isClass && (x in allClassesIdentities[className][2]) && isProcedure){
			print("Warning: A new variable $x$ is being defined instead of assigning the member variable of class $className$,
					if you wish to assign the member variable add a prefix this. to it.");
		}
		return;
	
	case ^quotientAssignment(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^quotient(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^integerDivision(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^product(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^modulo(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^power(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^minus(x):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
	
	case ^cartesianProduct(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	//Booleans
	case ^equals(x, {y|z}):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		for(z in {y|z}){
			getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		}
		return;
	
	case ^equals(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^unEqual(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^greaterThan(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^lessThan(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^lessOrEqual(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^greaterOrEqual(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^not(x): 
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;
	
	case ^range(x, y, z):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^conjunction(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^disjunction(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^in(x, y): 
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;	
	
	//return, backtrack, continue, break, exit
	case ^return(^variable(x)):
		getUsedVariables(^variable(x), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^return("nil"):	 return;
	
	case ^return([a|b]): 
		for(y in [a|b]){
		    getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);   
		}
		return;
	
	case ^return(x):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);   
	
	case ^backtrack():	 return;
	case ^break():		 return;
	case ^continue():	 return;
	case ^exit():		 return;
	
	//call
										
	case ^call("load", x):
		if(isProcedure){
			for(y in x){
				print("NOW CHECKING LOADED FILE $y$");
				l := readFile(y); 
				l := +/ [ g + "\n" : g in l ];
				l := parseStatements(l);	
				identifyAllProcedures(l, allProceduresIdentities);
				identifyAllClasses(l, allClassesIdentities);
				checkCode(l, definedVars, allUsedVars, false, "", {}, {}, allProceduresIdentities, false,
						{}, {}, {}, false, "", allClassesIdentities);
				print("DONE CHECKING LOADED FILE $y$");
			}
		}
		return;
	
	case ^call(^variable(x), y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return; // This case only happens if you give a ^call in a match statements.
	
	case ^call(^memberAccess(^variable(x), ^variable(y)), z):	
		if(str(y) in {c : b in allClassesIdentities, c in domain(b[2][3])}){
			getUsedVariables(^variable(x), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		else{
			print("Attention! calling class procedure $y$ for object $x$ is uncorrect!");
			getUsedVariables(^variable(x), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		for(w in z){
			getUsedVariables(w, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
	
	case ^call(x, y): 	
		allPredefinedProcedures := ["print","throw","abort","isString","nDecimalPlaces","str","canonical",
									"parseStatements","readFile","arb","first","last","from","fromB","fromE",
									"domain","max","min","pow","range","reverse","sort","char","endsWith",
									"eval","execute","matches","join","replace","replaceFirst","split",
									"toLowerCase","toUpperCase","trim","args","evalTerm","fct","getTerm",
									"makeTerm","parse","abs","ceil","floor","mathConst","nextProbablePrime",
									"int","rational","real","sin","cos","tan","asin","acos","atan","exp",
									"log","log10","sqrt","cbrt","round","ulp","signum","sinh","cosh","tanh",
									"isPrime","isProbablePrime","random","rnd","shuffle","nextPermutation",
									"permutations","isBoolean","isError","isInfinite","isInteger","isList",
									"isMap","isNumber","isProcedure","isRational","isReal","isSet","isString",
									"isTerm","trace","setBreak","rmBreak","lsBreak","step","uStep","fStep",
									"finish","finishLoop","resume","reset","dbgHelp","appendFile","deleteFile",
									"get","loadLibrary","multiLineMode","nprint","nprintErr","printErr",
									"read","writeFile","cacheStats","clearCache","compare","getScope","logo",
									"sleep","now","run","isObject","stop"];
		if(x in allPredefinedProcedures){
			for(z in y){
				getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
						procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
						forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
			}
			return;
		}
		procedureName := x;
		counter := 1;
		if(x in domain(allProceduresIdentities)){
			if(#y != #allProceduresIdentities[procedureName]){
				print("ATTENTION! Procedure $procedureName$ is being called with $#y$ parameter(s) instead of 
						$#allProceduresIdentities[procedureName]$ parameter(s)");
			}
			for(z in y){
				match(z){
											
				case ^variable(a):
					if(allProceduresIdentities[procedureName][counter] == "0"){
						getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
								procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
								forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
					}
					else{
						definedVars := definedVars + {a};
						getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
								procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
								forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
					}
					counter := counter + 1;
				case [a|b]:	
					for(x in [a|b]){
						getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
								procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
								forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
					}
											
				default:	
					getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
							procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
							forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
					counter := counter + 1;
				}
			}
		}
		else{
			if(isClass && (x in domain(allClassesIdentities[className][3]))){
				for(z in y){
					getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
							procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
							forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
				}
			}
			else{
				if(isProcedure && (x in procParameters)){
					print("ATTENTION parameter $x$ in procedure $procName$ is being used as a procedure, check that this is correct.");
					usedVariables += {x};
					for(z in y){
						getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
								procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
								forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
					}
				}
				else{
					if(isProcedure && (x in procEmbeddedProcedures)){
						for(z in y){
							getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
									procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
									forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
						}
					}
					else{
						if(x in domain(allClassesIdentities)){
							for(z in y){
								getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
										procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
										forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
							}
						}
						else{
							n := str(procedureName);
							if("." in n){				//Object calling a procedure of its class
								counter := 1;
								position := 1;
								for(x in n){
									if(x == "."){
										position := counter;
									}
									counter += 1;
								}
								found := false;
								spliting := [];
								spliting += [n[1..(position-1)]];
								spliting += [n[(position+1)..]];
								for(o in allClassesIdentities){
									if(spliting[2] in domain(o[2][3])){
										found := true;
										getUsedVariables(spliting[1], usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
												procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
												forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
										if(#y != #(o[2][3][spliting[2]])){
											print("ATTENTION! Procedure $spliting[2]$ of class $o[1]$ is being called with $#y$ parameter(s) 
													instead of $#(o[2][3][spliting[2]])$ parameter(s)");
										}
										for(z in y){
											getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
													procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
													forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
										}
									}
								}
								if(found == false){
									print("Calling of procedure $spliting[2]$ for object $spliting[1]$ is uncorrect!");
									getUsedVariables(^variable(spliting[1]), usedVariables, allUsedVars, tempDefinedVars, definedVars,
											isProcedure, procName, procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities,
											forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
									for(z in y){
										getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
												procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
												forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
									}
								}
							}
							else{
								if(!(str(x) in definedVars)){
									print("PROCEDURE $x$ is undefined!");
								}
								else{
									getUsedVariables(^variable(x), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure,
											procName, procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities,
											forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
								}
								for(z in y){
									getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
											procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
											forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
								}
							}
						}
					}
				}
			}
		}
		return;
	
	//Iterators
	case {[a|b]}: 
		for(y in [a|b]){
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		} 
		return;
	
	case {a|b}: 
		for(y in {a|b}){
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		} 
		return;
	
	case [^setlIteration(x,y,z)]:
		getUsedVariables(^setIteration(x,y,z), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;
	
	case ^setIteration([a|b], y, z):
		iteratorCase := true;
		for(x in [a|b]){
			getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
					// can use local variables -> 'expression' can use any locally defined variable
		}
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				//can use local variables -> 'condition' can use any locally defined variable
		return;
	
	case ^setIteration(x, y, z):
		iteratorCase := true;
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				// can use local variables -> 'expression' can use any locally defined variable
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				//can use local variables -> 'condition' can use any locally defined variable
		return;
									   
	case ^setlIteration([a|b], y, z):
		iteratorCase := true;
		for(x in [a|b]){
			getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
					// can use local variables -> 'expression' can use any locally defined variable
		}
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				//can use local variables -> 'condition' can use any locally defined variable
		return;
	
	case ^setlIteration(x, y, z):
		iteratorCase := true;
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				// can use local variables -> 'expression' can use any locally defined variable
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
				//can use local variables -> 'condition' can use any locally defined variable
		return;
									   
	case ^setlIterator(^variable(x), [y], z): 
		addDefinedVariables(^assignment(^variable(x), 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
		// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		for(w in [y]){
			getUsedVariables(w, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			//v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			for(w in [y]){
				getUsedVariables(w, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
						procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
						forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
			}
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;

	case ^setlIterator(^variable(x), y, z):
		addDefinedVariables(^assignment(^variable(x), 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
		// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		getUsedVariables(y, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			//v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
						procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
						forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;

	case ^setlIterator(^assignListConstructor(x), [y], z): 			
		for(w in x){
			addDefinedVariables(^assignment(w, 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
			// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		}
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		for(w in [y]){
			getUsedVariables(w, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			for(w in [y]){
				getUsedVariables(w, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
						procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
						forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
			}
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;

	case ^setlIterator(^assignListConstructor(x), y, z):
		for(w in x){
			addDefinedVariables(^assignment(w, 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
			// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		}
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		getUsedVariables(y, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;
		
	case ^setlIterator(x, [y], z): 			
		for(w in x){
			addDefinedVariables(^assignment(w, 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
			// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		}
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		for(w in [y]){
			getUsedVariables(w, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			for(w in [y]){
				getUsedVariables(w, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
						procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
						forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
			}
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;

	case ^setlIterator(x, y, z): 			
		for(w in x){
			addDefinedVariables(^assignment(w, 1), tempDefinedVars, isClass, className, allClassesIdentities, isProcedure, false); 
			// Xs -- Here I just wrote any imaginary assignment just to add the variable x to the list of temp. defined variables
		}
		if(forLoopCase == true){
			forLoopTmpDefVars := forLoopTmpDefVars + tempDefinedVars;
		}
		usedVariablesInS := {};
		getUsedVariables(y, usedVariablesInS, {}, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		//print(usedVariablesInS);
		for(v in usedVariablesInS){ // Checking that any S is defined before locally or globally
			v := str(v);
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				usedVariables := usedVariables + {v};
			}
			if(!((v in tempDefinedVars) || (v in definedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp))){
				print("Variable " + v + " in an iterator is called without being defined !");
			}
		}
		if(!iteratorCase){ // for the loops' cases
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); // Ss
		}
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); //Any extra setIterator
		return;
										
	
	case ^notEqual(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^stringConstructor(x, y):
		for(z in y){
			getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
	
	case ^collectionAccess(x, [y, z, zz]):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(zz, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;	
	
	case ^collectionAccess(x, [y]):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;	
	
	
	case ^collectionAccess(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^collectMap(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^collectionAccessRangeDummy():		return;						   
									   
	case ^cardinality(x):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;									
	
	case ^exists(^setlIterator(^variable(a), b, c), y):
		definedVars += {a};
		allUsedVars += {a};
		getUsedVariables(^setlIterator(^variable(a), b, c), usedVariables, allUsedVars, tempDefinedVars, definedVars,
				isProcedure, procName, procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities,
				forLoopCase,forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^exists(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^forall(^setlIterator(^variable(a), b, c), y):
		definedVars += {a};
		allUsedVars += {a};
		getUsedVariables(^setlIterator(^variable(a), b, c), usedVariables, allUsedVars, tempDefinedVars, definedVars,
				isProcedure, procName, procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities,
				forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^forall(x, y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
									   
	case ^sumOfMembers([a|b]):
		for(y in [a|b]){
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		}
		return;
	
	case ^sumOfMembersBinary(x, [a|b]):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		for(y in [a|b]){
			getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		}
		return;
	
	case ^literalConstructor(x):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^assert(x,y):
		getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className); 
		return;
	
	case ^explicitListWithRest([^in(^variable(a), b)], y): 
		tempDefinedVars += {a};
		getUsedVariables(^in(^variable(a), b), usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;
	
	case ^explicitListWithRest([a|b], y): 
		for(x in [a|b]){
			getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		getUsedVariables(y, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return;
	
	case ^lambdaDefinition(y, z):	 	
		getProcedureParameters(^procedure(y, z), definedVars, {});
		getUsedVariables(z, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
				procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
				forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		return; // This is always a directly used lamda definition
	
	case ^memberAccess(x, y):
		if((str(x) != "this") && isClass){
			if(!isProcedure){
				found := false;
				tempXUsed := {};
				getUsedVariables(x, tempXUsed, {}, {}, {}, false, "", {}, {}, false, {}, false, {}, {}, {}, {}, false, "");
				tempX := first(tempXUsed);
				tempYUsed := {};
				getUsedVariables(y, tempYUsed, {}, {}, {}, false, "", {}, {}, false, {}, false, {}, {}, {}, {}, false, "");
				tempY := first(tempYUsed);
				for(o in allClassesIdentities){
					if(tempY in o[2][2]){
						found := true;
					}
				}
				if(found == false){
					if(isClass && isProcedure){
						print("Usage of variable $tempY$ for object $tempX$ in procedure $procName$ of class $className$ is uncorrect");
					}
					else{
						if(isProcedure){
							print("Usage of variable $tempY$ for object $tempX$ in procedure $procName$ is uncorrect");
						}
						else{
							if(isClass){
								print("Usage of variable $tempY$ for object $tempX$ in class $className$ is uncorrect");
							}
							else{
								print("Usage of variable $tempY$ for object $tempX$ is uncorrect");
							}
						}
					}
				}
			}
			else{
				if(!(str(y) in {m : n in allClassesIdentities, m in n[2][2]})){
					if(isClass && isProcedure){
						print("Usage of class variable $y$ for object $x$ in procedure $procName$ of class $className$ is uncorrect");
					}
					else{
						if(isProcedure){
							print("Usage of class variable $y$ for object $x$ in procedure $procName$ is uncorrect");
						}
						else{
							if(isClass){
								print("Usage of class variable $y$ for object $x$ in class $className$ is uncorrect");
							}
							else{
								print("Usage of class variable $y$ for object $x$ is uncorrect");
							}
						}
					}
				}
			}
			getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
		else{
			if((str(x) != "this") && isClass && (!(str(y) in allClassesIdentities[className][2]))){
				print("Class variable $y$ does not exist !");
			}
		}
		if(!isClass){
			found := false;
			tempXUsed := {};
			getUsedVariables(x, tempXUsed, {}, {}, {}, false, "", {}, {}, false, {}, false, {}, {}, {}, {}, false, "");
			tempX := first(tempXUsed);
			tempYUsed := {};
			getUsedVariables(y, tempYUsed, {}, {}, {}, false, "", {}, {}, false, {}, false, {}, {}, {}, {}, false, "");
			tempY := first(tempYUsed);
			for(o in allClassesIdentities){
				if(tempY in o[2][2]){
					found := true;
				}
			}
			if(found == false){
				if(!(isProcedure && (str(x) in procParameters) && (str(y) in {m : n in allClassesIdentities, m in n[2][2]}))){ 
								//This condition is for cases were a procedure parameter might be actually an object
					if(isClass && isProcedure){
						print("Usage of variable $tempY$ for object $tempX$ in procedure $procName$ of class $className$ is uncorrect");
					}
					else{
						if(isProcedure){
							print("Usage of variable $tempY$ for object $tempX$ in procedure $procName$ is uncorrect");
						}
						else{
							if(isClass){
								print("Usage of variable $tempY$ for object $tempX$ in class $className$ is uncorrect");
							}
							else{
								print("Usage of variable $tempY$ for object $tempX$ is uncorrect");
							}
						}
					}
				}
			}
			getUsedVariables(x, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName,
					procParameters, procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase,
					forLoopTmpDefVars, exceptionTmp, matchTmp, allClassesIdentities, isClass, className);
		}
	
	default:
		temp := {};
		getMatchedVariables(l, temp);
		getMatchedVariables(l, usedVariables);
		if(temp != {}){
			//print("Fakes in getUsedVariables : \""+ canonical(l) + "\" -> & got " + temp + " out of it");
		}
		else{
			//print("Fakes in getUsedVariables : \""+ canonical(l) + "\"");
		}
		return;
										
	}

};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

addDefinedVariables := procedure(l, rw definedVars, isClass, className, rw allClassesIdentities, isProcedure, classCheck) {	
//print("addDefinedVariables : " + canonical(l));
	match(l){
	
	case ^block(x):
		for(y in x){
			addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		}
		return;
	
	case ^variable(x):
		return;											   
	
	case ^assignment(^variable(x), ^procedure(y, z)):
		return;   //These 3 cases are only reached when checking classes, otherwise in any other
	
	case ^assignment(^variable(x), ^cachedProcedure(y, z)):
		return;	  //case the checkProcedure function is directly called from the checkCode function
	
	case ^assignment(^variable(x), ^lambdaDefinition(y, z)):
		return;   //so in this case we just have to ignore them.
	
	
	case ^assignment(^variable(x), ^call(y, z)):
		definedVars := definedVars + {x};
		return;
	
	case ^assignment(^variable(x), y):
		definedVars := definedVars + {x};
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		if(isClass && (x in allClassesIdentities[className][2]) && isProcedure){
			print("Warning: A new variable $x$ is being defined instead of assigning the member variable of class 
				$className$, if you wish to assign the member variable add a prefix this. to it.");
		}
		return;
	
	case ^assignment(^memberAccess(x, y), _):
		if(classCheck && str(x) == "this"){
			definedVars := definedVars + {str(y)};
		}
		return; 
	
	case ^assignment(^assignListConstructor([a|b]), y):
		for(z in [a|b]){
			addDefinedVariables(^assignment(z,y), definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		}
		return;
	
	case ^assignment(x, y):
		return;
	
	//Mathematics
	case ^difference(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^sum(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^sumAssignment(x, y):
		if(isClass && (str(x) in allClassesIdentities[className][2]) && isProcedure){
			print("Warning: A new variable $x$ is being defined instead of assigning the member variable of class $className$,
					if you wish to assign the member variable add a prefix this. to it.");
		}
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck); return;
	
	case ^differenceAssignment(x, y):
		if(isClass && (str(x) in allClassesIdentities[className][2]) && isProcedure){
			print("Warning: A new variable $x$ is being defined instead of assigning the member variable of class $className$, 
					if you wish to assign the member variable add a prefix this. to it.");
		}
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck); return;
	
	case ^quotientAssignment(x, y):
		if(isClass && (str(x) in allClassesIdentities[className][2]) && isProcedure){
			print("Warning: A new variable $x$ is being defined instead of assigning the member variable of class $className$,
					if you wish to assign the member variable add a prefix this. to it.");
		}
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck); return;	
	
	case ^integerDivision(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^quotient(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^product(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^modulo(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^power(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	//Booleans
	case ^equals(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^notEqual(x, y): 
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^greaterThan(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^lessThan(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^lessOrEqual(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^greaterOrEqual(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^not(x):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;

	case ^iterator(x, y, z):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(z, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^range(x, y, z):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(z, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^conjunction(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^disjunction(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^in(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	//return, backtrack, continue, break, exit
	case ^return(x):	 return;
	
	case ^backtrack():	 return;
	
	case ^break():		 return;
	
	case ^continue():	 return;
	
	case ^exit():		 return;
	
	//call
	case ^call(_, y):	 return; // No use for it  here as I did consider all used and defined variables in the "getUsedVariables"
	
	//Iterators
	case {x}:
		//print("{x} is called in addDefinedVariables");
		return;
	
	case ^setlIteration(_,_,_):
		return; // Skip as everything concerning the iteration is recorded previously
	
	case ^setlIterator(_,_,_):
		return;
	
	//Other stuff
	case ^collectionAccess(x, y):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^collectionAccessRangeDummy():
		return;
	
	case ^cardinality(x):
		return; // It is only used but not defined.
	
	case ^exists(x, y):
		return;
	
	case ^forall(x, y):
		return;
	
	case ^sumOfMembers([a|b]):
		for(y in [a|b]){
			addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);	
		}
		return;
	
	case ^sumOfMembersBinary(x, [a|b]):
		addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		for(y in [a|b]){
			addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);	
		}
		return;
	
	case ^explicitListWithRest([a|b], y):
		for(x in [a|b]){
			addDefinedVariables(x, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		}
		addDefinedVariables(y, definedVars, isClass, className, allClassesIdentities, isProcedure, classCheck);
		return;
	
	case ^memberAccess(_,_):
		return; //Accessing class variables only uses objects and might define their class variables BUT never defines any external variable
	
	default:
		//print("Fakes in addDefinedVariables :\""+ canonical(l) + "\"");
		return;
	}

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
checkCode := procedure(l, rw definedVars, rw allUsedVars, isProcedure, procName, procParameters, rw procEmbeddedProcedures,
				rw allProceduresIdentities, forLoopCase, rw forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, rw allClassesIdentities) {
//print("checkCode : " + canonical(l));

match(l){
	case ^block(l2):  		
		for(y in l2){
			checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures,
				allProceduresIdentities, forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
		return;

	case ^assignment(^variable(x), ^procedure(y, z)):
		if(!isProcedure){
			if(!isClass){
				checkProcedure(x,^procedure(y,z), allProceduresIdentities, allClassesIdentities,{}, isClass, className);
			}
			else{
			    checkProcedure(x,^procedure(y,z), allProceduresIdentities, allClassesIdentities, allClassesIdentities[className][2] + {"this"},
							isClass, className);															   
			}
		}
		else{
			procEmbeddedProcedures += {x};
			definedVars := definedVars + {x};
			allUsedVars += {x};
			getProcedureParameters(y, definedVars, {});
			checkCode(z, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
		return;
	
	case ^assignment(^variable(x), ^cachedProcedure(y, z)) :	
		if(!isProcedure){
			if(!isClass){
				checkProcedure(x,^procedure(y,z), allProceduresIdentities, allClassesIdentities, {}, isClass, className);
			}
			else{
			    checkProcedure(x,^procedure(y,z), allProceduresIdentities, allClassesIdentities,
							allClassesIdentities[className][2] + {"this"}, isClass, className);
			}
		}
		else{
			procEmbeddedProcedures += {x};
			definedVars := definedVars + {x};
			allUsedVars += {x};
			getProcedureParameters(y, definedVars, {});
			checkCode(z, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
		return;
	
	case ^assignment(^variable(x), ^lambdaDefinition(y, z))	:	
		if(!isProcedure){
			if(!isClass){
			    checkProcedure(x, ^procedure(y, ^block([z])), allProceduresIdentities, allClassesIdentities, {}, isClass, className);
			}
			else{
				checkProcedure(x, ^procedure(y, ^block([z])), allProceduresIdentities, allClassesIdentities,
							allClassesIdentities[className][2] + {"this"}, isClass, className);
			}
		}
		else{
			procEmbeddedProcedures += {x};
			definedVars := definedVars + {x};
			allUsedVars += {x};
			getProcedureParameters(y, definedVars, {});
			checkCode(z, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
		return;
																
	//Adding members to existing objects
	case ^assignment(^memberAccess(^variable(a),^variable(b)), ^procedure(y, z)) :	
		newClassName := "extra-" + str(a);
		//print(newClassName);
		if(!(newClassName in domain(allClassesIdentities))){
			oldClassProperties := {oc : oc in allClassesIdentities | str(a) in oc[2][4]};
			if(#oldClassProperties != 0){
			    oldClassProperties := first(oldClassProperties);
				oldClassProperties := oldClassProperties[2];
			}
			else{
				a := {f : g in allClassesIdentities, f in g[2][1]};
				b := {f : g in allClassesIdentities, f in g[2][2]};
				c := {f : g in allClassesIdentities, f in g[2][3]};
				d := {f : g in allClassesIdentities, f in g[2][4]};
				oldClassProperties := [a, b, c, d];
			}
			oldClassProperties[4] := {str(a)};
			//print(oldClassProperties);
			checkProcedure(b, ^procedure(y, z), oldClassProperties[3], allClassesIdentities,
						oldClassProperties[2] + {"this"}, isClass, className);
			allClassesIdentities := allClassesIdentities + {[newClassName, oldClassProperties]};
		}
		else{
			checkProcedure(b, ^procedure(y, z), allClassesIdentities[newClassName][3], allClassesIdentities,
						allClassesIdentities[newClassName][2] + {"this"}, isClass, className);
		}
		allClassesIdentities[newClassName][3] += {[str(b),[]]};
		getProcedureIdentity(str(b), ^procedure(y, z), allClassesIdentities[newClassName][3]);
		return;
	
	case ^assignment(^memberAccess(^variable(a),^variable(b)), ^cachedProcedure(y, z)) :	
		newClassName := "extra-" + str(a);
		//print(newClassName);
		if(!(newClassName in domain(allClassesIdentities))){
			oldClassProperties := {oc : oc in allClassesIdentities | str(a) in oc[2][4]};
			if(#oldClassProperties != 0){
				oldClassProperties := first(oldClassProperties);
				oldClassProperties := oldClassProperties[2];
			}
			else{
				a := {f : g in allClassesIdentities, f in g[2][1]};
				b := {f : g in allClassesIdentities, f in g[2][2]};
				c := {f : g in allClassesIdentities, f in g[2][3]};
				d := {f : g in allClassesIdentities, f in g[2][4]};
				oldClassProperties := [a, b, c, d];
			}
			oldClassProperties[4] := {str(a)};
			//print(oldClassProperties);
			checkProcedure(b, ^procedure(y, z), oldClassProperties[3], allClassesIdentities,
						oldClassProperties[2] + {"this"}, isClass, className);
			allClassesIdentities += [newClassName, oldClassProperties];
		}
		else{
			checkProcedure(b, ^procedure(y, z), allClassesIdentities[newClassName][3], allClassesIdentities, 
						allClassesIdentities[newClassName][2] + {"this"}, isClass, className);
		}
		allClassesIdentities[newClassName][3] += {[str(b),[]]};
		getProcedureIdentity(str(b), ^procedure(y, z), allClassesIdentities[newClassName][3]);
		return;	
																
	case ^assignment(^memberAccess(^variable(a),^variable(b)), ^lambdaDefinition(y, z))	:
		newClassName := "extra-" + str(a);
		//print(newClassName);
		if(!(newClassName in domain(allClassesIdentities))){
			oldClassProperties := {oc : oc in allClassesIdentities | str(a) in oc[2][4]};
			if(#oldClassProperties != 0){
				oldClassProperties := first(oldClassProperties);
				oldClassProperties := oldClassProperties[2];
			}
			else{
				a := {f : g in allClassesIdentities, f in g[2][1]};
				b := {f : g in allClassesIdentities, f in g[2][2]};
				c := {f : g in allClassesIdentities, f in g[2][3]};
				d := {f : g in allClassesIdentities, f in g[2][4]};
				oldClassProperties := [a, b, c, d];
			}
			oldClassProperties[4] := {str(a)};
			//print(oldClassProperties);
			checkProcedure(b, ^procedure(y, ^block([z])), oldClassProperties[3], allClassesIdentities,
						oldClassProperties[2] + {"this"}, isClass, className);
			allClassesIdentities += [newClassName, oldClassProperties];
		}
		else{
			checkProcedure(b, ^procedure(y, ^block([z])), allClassesIdentities[newClassName][3], allClassesIdentities,
						allClassesIdentities[newClassName][2] + {"this"}, isClass, className);
		}
		allClassesIdentities[newClassName][3] += {[str(b),[]]};
		getProcedureIdentity(str(b), ^procedure(y, ^block([z])), allClassesIdentities[newClassName][3]);
		return;
	
	case ^ifThen(x): 
		for(y in x) 
		{
			checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		} 
		return;
	
	case ^ifThenElseIfBranch(x, y): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities); 
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities); 
		return;
	
	case ^ifThenBranch(cond, then): 
		checkCode(cond, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(then, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^ifThenElseBranch(x): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
									   
	case ^while(x, y): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^for(x, y, z): 
		forLoopCase := true;
		temp := forLoopTmpDefVars;
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(z, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities); 
		forLoopTmpDefVars := temp; //return it to the way it was in case they were nested forloops.
		forLoopCase := false;
		return;
	
	case ^tryCatch(x, [a|b]): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		for(y in [a|b]){
		    checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
						forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
		return;
	
	case ^tryCatch(x, y): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^tryCatchLngBranch(x, y): 
		addDefinedVariables(^assignment(x,1), exceptionTmp, isClass, className, allClassesIdentities, isProcedure, false);
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^tryCatchUsrBranch(x, y): 
		addDefinedVariables(^assignment(x,1), exceptionTmp, isClass, className, allClassesIdentities, isProcedure, false);
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^tryCatchBranch(x, y): 
		addDefinedVariables(^assignment(x,1), exceptionTmp, isClass, className, allClassesIdentities, isProcedure, false);
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^check(x, y): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^switch(x): 
		for(y in x) 
		{
			checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
						forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		} 
		return;
	
	case ^switchCaseBranch(cond, do):
		checkCode(cond, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(do, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities); 
		return;
	
	case ^switchDefaultBranch(x): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities); 
		return;
	
	case ^match(x, y): 
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		for(z in y) 
		{
			checkCode(z, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities, 
						forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		} 
		return;
	
	case ^matchCaseBranch([v],cond,do) : 
		getMatchedVariables(v, matchTmp);
		usedVarsInMatch := {};
		checkCode(cond, definedVars, usedVarsInMatch, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(do, definedVars, usedVarsInMatch, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		allVariablesAreDefined := true;
		undefinedVariables := {};
		for(v in usedVarsInMatch){
			v := str(v);
			if((v in definedVars) && (!((v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				allUsedVars := allUsedVars + {v};
			}
			if(!(v in definedVars || v in forLoopTmpDefVars || v in exceptionTmp || v in matchTmp)){
			allVariablesAreDefined := false;
			undefinedVariables := undefinedVariables + {v};
			}
		}
		if(allVariablesAreDefined == false){
			if(isProcedure){
				if(#undefinedVariables == 1){
					print("Variable " + undefinedVariables + " is called to be used in a match statement in procedure called " +
								procName + " without being defined !");
				}
				else{
					print("Variables " + undefinedVariables + " are called to be used in a match statement in procedure called " +
								procName + " without being defined !");													
				}
			}
			else{
				if(#undefinedVariables == 1){
					print("Variable " + undefinedVariables + "in a match statement is called to be used without being defined !");
				}
				else{
					print("Variables " + undefinedVariables + "in a match statement are called to be used without being defined !");													
				}
			}
		}
		return;
	
	case ^matchRegexBranch(x,y,cond,do) :
		getMatchedVariables(x, matchTmp);
		getMatchedVariables(y, matchTmp);
		usedVarsInMatch := {};
		checkCode(cond, definedVars, usedVarsInMatch, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
				forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(do, definedVars, usedVarsInMatch, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
				forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		allVariablesAreDefined := true;
		undefinedVariables := {};
		for(v in usedVarsInMatch){
			v := str(v);
			if((v in definedVars) && (!((v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				allUsedVars := allUsedVars + {v};
			}
			if(!(v in definedVars || v in forLoopTmpDefVars || v in exceptionTmp || v in matchTmp)){
				allVariablesAreDefined := false;
				undefinedVariables := undefinedVariables + {v};
			}
		}
		if(allVariablesAreDefined == false){
			if(isProcedure){
				if(#undefinedVariables == 1){
					print("Variable " + undefinedVariables + " is called to be used in a match statement in procedure called " +
							procName + " without being defined !");
				}
				else{
					print("Variables " + undefinedVariables + " are called to be used in a match statement in procedure called " +
							procName + " without being defined !");
				}
			}
			else{
				if(#undefinedVariables == 1){
					print("Variable " + undefinedVariables + "in a match statement is called to be used without being defined !");
				}
				else{
					print("Variables " + undefinedVariables + "in a match statement are called to be used without being defined !");													
				}
			}
		}
		return;
	
	case ^matchDefaultBranch(x):  
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		return;
	
	case ^scan(^variable(x), y, z):	
		matchTmp += {x};
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
					for(w in z){
						checkCode(w, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
									forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
					}
	
	case ^scan(x, y, z):	
		checkCode(x, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(y, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		for(w in z){
			checkCode(w, definedVars, allUsedVars, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
						forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		}
	
	case ^classDefiner(w, ^setlClass(x, y, z)):	
		//w is the name of the class
		//x is the list of parameters
		//y is the block of the class
		//z is the block of class procedures
		isClass := true;
		className := w;
		definedVarsTmp := definedVars;
		allUsedVarsTmp := allUsedVars;
		classDefinedVars := allClassesIdentities[w][1];
		checkCode(y, classDefinedVars, {}, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		checkCode(z, classDefinedVars, {}, isProcedure, procName, procParameters, procEmbeddedProcedures, allProceduresIdentities,
					forLoopCase, forLoopTmpDefVars, exceptionTmp, matchTmp, isClass, className, allClassesIdentities);
		definedVars := definedVarsTmp;
		allUsedVars := allUsedVarsTmp;
													
													
	default:		
		usedVariables := {};
		tempDefinedVars := {};
		iteratorCase := false;
		getUsedVariables(l, usedVariables, allUsedVars, tempDefinedVars, definedVars, isProcedure, procName, procParameters,
					procEmbeddedProcedures, iteratorCase, allProceduresIdentities, forLoopCase, forLoopTmpDefVars, exceptionTmp,
					matchTmp, allClassesIdentities, isClass, className);
		allVariablesAreDefined := true;
		undefinedVariables := {};
		for(v in usedVariables){
			v := str(v);
			if(("[" in v) && ("]" in v)){    //for the case where the collectionAccess is to be used forcely by the user 
				pos := 1;					 //-- x[1] instead of collectionAccess(^variable("x"), [1]);
				while(true){
					if(v[pos] == "["){
						break;
					}
					pos += 1;
				}
				v := v[..(pos-1)];
			}
			if((v in definedVars) && (!((v in tempDefinedVars) || (v in forLoopTmpDefVars) || (v in exceptionTmp) || (v in matchTmp)))){
				allUsedVars := allUsedVars + {v};
			}
			if(!(v in definedVars || v in tempDefinedVars || v in forLoopTmpDefVars || v in exceptionTmp || v in matchTmp)){
				allPredefinedProcedures := {"print","throw","abort","isString","nDecimalPlaces","str","canonical",
											"parseStatements","readFile","arb","first","last","from","fromB","fromE",
											"domain","max","min","pow","range","reverse","sort","char","endsWith",
											"eval","execute","matches","join","replace","replaceFirst","split",
											"toLowerCase","toUpperCase","trim","args","evalTerm","fct","getTerm",
											"makeTerm","parse","abs","ceil","floor","mathConst","nextProbablePrime",
											"int","rational","real","sin","cos","tan","asin","acos","atan","exp",
											"log","log10","sqrt","cbrt","round","ulp","signum","sinh","cosh","tanh",
											"isPrime","isProbablePrime","random","rnd","shuffle","nextPermutation",
											"permutations","isBoolean","isError","isInfinite","isInteger","isList",
											"isMap","isNumber","isProcedure","isRational","isReal","isSet","isString",
											"isTerm","trace","setBreak","rmBreak","lsBreak","step","uStep","fStep",
											"finish","finishLoop","resume","reset","dbgHelp","appendFile","deleteFile",
											"get","load","loadLibrary","multiLineMode","nprint","nprintErr","printErr",
											"read","writeFile","cacheStats","clearCache","compare","getScope","logo",
											"sleep","now","run","isObject","stop"};
				if(!((v in domain(allProceduresIdentities)) || (v in allPredefinedProcedures))){
					allVariablesAreDefined := false;
					undefinedVariables := undefinedVariables + {v};
					//print("FORTEMP : $forLoopTmpDefVars$");
				}
				else{
					print("ATTENTION! Procedure \"$v$\" is being used not as a procedure maybe a parameter to be called,
							please check that this is correct.");
				}
			}
		}
		if(allVariablesAreDefined == false){
			if(isProcedure){
				if(!isClass){
					if(#undefinedVariables == 1){
						print("Variable " + undefinedVariables + " is called to be used in procedure called " +
								procName + " without being defined !");
					}
					else{
						print("Variables " + undefinedVariables + " are called to be used in procedure called " 
								+ procName + " without being defined !");													   
					}
				}
				else{
					if(#undefinedVariables == 1){
						print("Variable " + undefinedVariables + " is called to be used in procedure called " +
								procName + " in class " + className + " without being defined !");
					}
					else{
						print("Variables " + undefinedVariables + " are called to be used in procedure called " +
								procName + " in class " + className + " without being defined !");													   
					}
				}
			}
			else{
				if(!isClass){
					if(#undefinedVariables == 1){
						print("Variable " + undefinedVariables + " is called to be used without being defined !");
					}
					else{
						print("Variables " + undefinedVariables + " are called to be used without being defined !");
					}
				}
				else{
					if(#undefinedVariables == 1){
						print("Variable " + undefinedVariables + " is called in class " + className +
								" to be used without being defined !");
					}
					else{
						print("Variables " + undefinedVariables + " are called in class " + className + " to be used without being defined !");													      
					}
				}
			}
		}
		temp := definedVars;
		addDefinedVariables(l, definedVars, isClass, className, allClassesIdentities, isProcedure, false);
		temp2 := definedVars - temp;
		temp3 := temp2 - (matchTmp+forLoopTmpDefVars);  // for the case where iterators are replaced as "v := str(v)"
		definedVars := temp + temp3;
		return;
}
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Getting the file directory of the file to check
main := procedure(params){
for(file in params){
	print("NOW CHECKING $file$");
	file := str(file);
	listOfLines := readFile(file); 
	listOfLinesSeparated := +/ [ g + "\n" : g in listOfLines ];
	statements := parseStatements(listOfLinesSeparated);

	definedVars := {};
	allUsedVars := {};
	allProceduresIdentities := {};
	allClassesIdentities := {};
	
	identifyAllProcedures(statements, allProceduresIdentities);
	identifyAllClasses(statements, allClassesIdentities);
	analyzeAllLoadedFiles(statements, definedVars, allUsedVars, allProceduresIdentities, allClassesIdentities);
	checkCode(statements, definedVars, allUsedVars, false, "", {}, {}, allProceduresIdentities, false, {}, {}, {}, false, "", allClassesIdentities);
	unUsedVars := definedVars-allUsedVars;
	if(#unUsedVars != 0)
	{
		if(#unUsedVars == 1){
		   print("Variable " + unUsedVars + " is defined but never used in the whole code! unless it was assigned to a returned procedure");
		}
		else{
		   print("Variables " + unUsedVars + " are defined but never used in the whole code! unless they were assigned to a returned procedure");
		
		}
	}
	print("DONE CHECKING $file$");
}
};

main(params);